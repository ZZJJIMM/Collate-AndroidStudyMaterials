#2019/10/11
#红黑二叉树学习路径：（https://mp.weixin.qq.com/s/Z4joQJMUph2Kwsl_6N319w）对红黑树进行了代码层面实际操作
#红黑二叉树（https://www.jianshu.com/p/e136ec79235c）：通过简单的语言与形象的流程图，更加的容易理解，在该文章中详细的描述的在各种情形下的插入结点以及删除结点应该做的处理方法
-对二叉查找树，平衡二叉树，红黑树都描述了一个清晰地概念
1.二叉查找树（BST）：
	-若左子树不空，则左子树上所有节点的值均小于他的根节点值
	-若右子树不空，则右子树上所有节点的值均大于他的根节点值
	-左右子节点也为二叉排序树
	-没有键值相等的节点
2.红黑树（Red-Black Tree，以下简称RBTree）
	-根节点是黑色。
	-树的任一节点是红色或黑色。
	-每个红色节点的两个子节点都是黑色。
	-从任一节点到其每个叶子结点的所有路径都包含相同数目的黑色节点。(这个指的是从节点A为起点到叶子结点(值得提醒注意的是，在Java中，叶子结点是为null的结点。)这一条链的黑节点数量都是相同的)（错误理解：以节点A为起点，左侧的所有黑色节点数量等于右侧的所有黑色节点数）
	-空节点默认是黑色的（每个叶子结点（NIL）是黑色。）

	通过性质：根节点为黑色可以得出：如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。
 	描述：
 	RBTree在本质上还是一棵BST树，但是它在插入和删除数据的时候会通过变色和自旋来保持树的平衡，即保证树的高度在[logN,logN+1]，将树的查找时间复杂度始终保持在logN,同时RBTree的插入和删除时间复杂度也都是logN,所以RBTree的查找接近于理想的BST。

 	红黑树的自旋：
 	RBTree的自旋主要目的是为了让节点的颜色符合上面的性质，从而使树的高度达到平衡。
 	RBTree的旋转分为左旋和右旋，左边子节点升到父节点位置为右旋，右边子节点升到父节点为左旋。
	左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。

	右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。

	左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了。
	右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了。
	

	学习红黑树的过程中最困惑的不是自旋和变色，而是自旋和变色的时机，钻了不少死胡同。这里总结一下（仅当是左边树情况下，右边树情况只要将左右颠倒即可）：

	删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。

	红黑树新增：
		描述：插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：
			-1.从根结点开始查找；
			-2.若根结点为空，那么插入结点作为根结点，结束。
			-3.若根结点不为空，那么把根结点作为当前结点；
			-4.若当前结点为null，返回当前结点的父结点，结束。
			-5.若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。
			-6.若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；
			-7.若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；

		I代表插入结点，P代表插入结点的父结点，S代表插入结点的叔叔结点，PP代表插入结点的祖父结点
		插入情景1：红黑树为空树
			处理：把插入结点作为根结点，并把结点设置为黑色。
		插入情景2：插入结点的Key已存在
			处理：
			-把I设为当前结点的颜色
			-更新当前结点的值为插入结点的值
		插入情景3：插入结点的父结点为黑结点
			处理：直接插入。
		插入情景4：插入结点的父结点为红结点
		插入情景4.1：叔叔结点存在并且为红结点
			处理：
			-将P和S设置为黑色
			-将PP设置为红色
			-把PP设置为当前插入结点
		插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点
		插入情景4.2.1：插入结点是其父结点的左子结点
			处理：
			-将P设为黑色
			-将PP设为红色
			-对PP进行右旋
		插入情景4.2.2：插入结点是其父结点的右子结点
			处理：
			-对P进行左旋
			-把P设置为插入结点，得到情景4.2.1
			-进行情景4.2.1的处理
		插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点
		插入情景4.3.1：插入结点是其父结点的右子结点
			处理：
			-将P设为黑色
			-将PP设为红色
			-对PP进行左旋
		插入情景4.3.2：插入结点是其父结点的右子结点
			处理：
			-对P进行右旋
			-把P设置为插入结点，得到情景4.3.1
			-进行情景4.3.1的处理


	红黑树删除：
		描述：红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。

		二叉树删除结点找替代结点有3种情情景：

		情景1：若删除结点无子结点，直接删除
		情景2：若删除结点只有一个子结点，用子结点替换删除结点
		情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点
		补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最左结点）替代吗？可以的。

		R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。
		删除情景1：替换结点是红色结点
		删除情景2：替换结点是黑结点
		删除情景2.1：替换结点是其父结点的左子结点
		删除情景2.1.1：替换结点的兄弟结点是红结点
			处理：
			-将S设为黑色
			-将P设为红色
			-对P进行左旋，得到情景2.1.2.3
			-进行情景2.1.2.3的处理
		删除情景2.1.2：替换结点的兄弟结点是黑结点
		删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色
			处理：
			-将S的颜色设为P的颜色
			-将P设为黑色
			-将SR设为黑色
			-对P进行左旋
		删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点
			处理：
			-将S设为红色
			-将SL设为黑色
			-对S进行右旋，得到情景2.1.2.1
			-进行情景2.1.2.1的处理
		删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点
			处理：
			-将S设为红色
			-把P作为新的替换结点
			-重新进行删除结点情景处理
		删除情景2.2：替换结点是其父结点的右子结点
		删除情景2.2.1：替换结点的兄弟结点是红结点
			处理：
			-将S设为黑色
			-将P设为红色
			-对P进行右旋，得到情景2.2.2.3
			-进行情景2.2.2.3的处理
		删除情景2.2.2：替换结点的兄弟结点是黑结点
		删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色
			处理：
			-将S的颜色设为P的颜色
			-将P设为黑色
			-将SL设为黑色
			-对P进行右旋
		删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点
			处理：
			-将S设为红色
			-将SR设为黑色
			-对S进行左旋，得到情景2.2.2.1
			-进行情景2.2.2.1的处理
		删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点
			处理：
			-将S设为红色
			-把P作为新的替换结点
			-重新进行删除结点情景处理

